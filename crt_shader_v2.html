<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML2Canvas CRT Filter - Static Mode (Fixed)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 20px;
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* åŸå§‹å†…å®¹å®¹å™¨ */
        #original-content {
            position: relative;
            z-index: 1;
        }

        /* CRT è¦†ç›–å±‚ */
        #crt-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 999998;
            overflow: auto;
            background: #000;
        }

        #crt-container.active {
            display: block;
        }

        /* CRT Canvas åŒ…è£…å™¨ */
        #crt-wrapper {
            position: relative;
            width: 100%;
            min-height: 100vh;
        }

        /* CRT Canvas */
        #crt-canvas {
            display: block;
            width: 100%;
            height: auto;
            pointer-events: none;
        }

        /* äº¤äº’å±‚ */
        #interaction-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            cursor: pointer;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 3em;
            color: #00ff41;
            text-shadow: 0 0 20px #00ff41;
            margin: 0;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 20px #00ff41; }
            to { text-shadow: 0 0 30px #00ff41, 0 0 40px #00ff41; }
        }

        .control-panel {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .control-panel h3 {
            color: #00ffff;
            margin-top: 0;
        }

        .terminal {
            background: #000;
            border: 2px solid #00ff41;
            border-radius: 5px;
            padding: 15px;
            margin: 20px 0;
            color: #00ff41;
            font-size: 14px;
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.2);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .card {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 255, 255, 0.2);
            border-color: #00ffff;
        }

        .neon-button {
            background: transparent;
            border: 2px solid #ff00ff;
            color: #ff00ff;
            padding: 10px 20px;
            font-family: inherit;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s ease;
            margin: 5px;
            text-transform: uppercase;
        }

        .neon-button:hover {
            background: #ff00ff;
            color: #000;
            box-shadow: 0 0 20px #ff00ff;
            transform: scale(1.05);
        }

        .neon-button:active {
            transform: scale(0.95);
        }

        .ascii-art {
            font-size: 12px;
            line-height: 1;
            color: #ffaa00;
            white-space: pre;
            text-align: center;
            margin: 30px 0;
            text-shadow: 0 0 10px #ffaa00;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff0000;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        .status-indicator.active {
            background: #00ff41;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .footer {
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            color: #aaa;
        }

        /* åŠ è½½åŠ¨ç”» */
        #loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 9999999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #loading-overlay.active {
            display: flex;
        }

        .loading-text {
            color: #00ff41;
            font-size: 24px;
            margin-top: 20px;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 255, 65, 0.3);
            border-top: 3px solid #00ff41;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

<!-- åŠ è½½è¦†ç›–å±‚ -->
<div id="loading-overlay">
    <div class="spinner"></div>
    <div class="loading-text">APPLYING CRT FILTER...</div>
</div>

<!-- CRT å®¹å™¨ -->
<div id="crt-container">
    <div id="crt-wrapper">
        <canvas id="crt-canvas"></canvas>
        <div id="interaction-layer"></div>
    </div>
</div>

<!-- åŸå§‹å†…å®¹ -->
<div id="original-content">
    <div class="header">
        <h1>HTML2CANVAS CRT SYSTEM</h1>
        <p style="color: #00ffff; font-size: 1.2em;">Static CRT Filter - One-Time Capture Mode (Fixed)</p>
    </div>

    <div class="control-panel">
        <h3>ğŸ›ï¸ CRT Control Panel</h3>
        <div style="margin-bottom: 15px;">
            <span class="status-indicator" id="statusIndicator"></span>
            <span>Status: <span id="statusText">READY</span></span>
        </div>

        <div>
            <button class="neon-button" onclick="CRT.apply()">APPLY CRT FILTER</button>
            <button class="neon-button" onclick="CRT.restore()">RESTORE ORIGINAL</button>
            <button class="neon-button" onclick="CRT.preset('gaming')">GAMING PRESET</button>
            <button class="neon-button" onclick="CRT.preset('retro')">RETRO PRESET</button>
        </div>
    </div>

    <div class="terminal">
        <div>$ system_status</div>
        <div id="terminalOutput">
            HTML2Canvas CRT Filter System v24.1.0 - STATIC MODE (FIXED)<br>
            âœ… One-time capture mode<br>
            âœ… Full interaction support<br>
            âœ… WebGL + Canvas 2D fallback<br>
            âœ… Click-through enabled<br>
            <br>
            Available Commands:<br>
            â€¢ CRT.apply() - Apply CRT filter to entire page<br>
            â€¢ CRT.restore() - Restore original page<br>
            â€¢ CRT.preset(name) - Apply visual preset<br>
            â€¢ CRT.adjust(param, value) - Fine-tune parameters<br>
        </div>
    </div>

    <div class="grid">
        <div class="card" onclick="alert('ğŸ® Card 1 clicked! CRT effect active!')">
            <h3>ğŸ–¥ï¸ Display Technology</h3>
            <p>Click me! Simulates authentic CRT monitor characteristics including phosphor glow, scanlines, and geometric distortion.</p>
        </div>

        <div class="card" onclick="alert('ğŸ“º Card 2 clicked! Interaction works!')">
            <h3>ğŸ“º Video Processing</h3>
            <p>Click me! One-time HTML-to-Canvas conversion with static CRT filtering. All interactions preserved!</p>
        </div>

        <div class="card" onclick="alert('ğŸ¯ Card 3 clicked! Perfect!')">
            <h3>ğŸ® Gaming Enhancement</h3>
            <p>Click me! Perfect for retro gaming aesthetics with multiple visual presets available.</p>
        </div>

        <div class="card" onclick="alert('âš™ï¸ Card 4 clicked! Awesome!')">
            <h3>ğŸ”§ Customization</h3>
            <p>Click me! Extensive parameter control for scanline intensity, phosphor characteristics, and more.</p>
        </div>
    </div>

    <div class="ascii-art">
        â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        â•‘  â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â•‘
        â•‘  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â•šâ•â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•  â•‘
        â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘       â•‘
        â•‘  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•‘       â•‘
        â•‘  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â•‘
        â•‘  â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•     â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â•  â•‘
        â•‘              STATIC CRT MODE - FIXED                  â•‘
        â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    </div>

    <div class="terminal">
        <div>$ diagnostic_info</div>
        <div>
            Mode: <span style="color: #ffff41;">Static (One-Time Capture)</span><br>
            Renderer: <span id="rendererInfo" style="color: #00ff41;">Detecting...</span><br>
            Interaction: <span style="color: #00ff41;">âœ… Enabled</span><br>
            Recursion: <span style="color: #00ff41;">âœ… Impossible</span><br>
            Performance: <span style="color: #00ff41;">âœ… Optimal</span>
        </div>
    </div>

    <div class="footer">
        <p>HTML2Canvas CRT Filter System â€¢ Static Mode Engine</p>
        <p>Developed by uk0 â€¢ 2025-01-10 â€¢ Version 24.1.0 (Fixed)</p>
    </div>
</div>

<!-- HTML2Canvas Library -->
<script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

<!-- CRT Filter System - STATIC MODE (FIXED) -->
<script>
    /**
     * HTML2Canvas CRT Filter System - STATIC MODE (FIXED)
     * æ”¯æŒ WebGL å’Œ Canvas 2D åŒæ¨¡å¼
     * @author uk0
     * @version 24.1.0
     * @date 2025-01-10
     */

    class StaticCRTSystem {
        constructor() {
            this.version = '24.1.0';
            this.active = false;
            this.renderMode = null; // 'webgl' or 'canvas2d'
            this.gl = null;
            this.ctx = null;
            this.program = null;
            this.texture = null;
            this.capturedCanvas = null;
            this.interactionMap = new Map();

            // CRT é…ç½®å‚æ•°
            this.config = {
                intensity: 1.0,
                scanlineStrength: 0.6,
                scanlineCount: 1080,
                phosphorGlow: 0.25,
                rgbShift: 0.4,
                curvature: 0.1,
                vignette: 0.2,
                brightness: 1.0,
                contrast: 1.1,
                saturation: 1.0,
                gamma: 2.2,
                noiseAmount: 0.015,
                flickerAmount: 0.0,
                maskStrength: 0.3,
            };

            // é¢„è®¾
            this.presets = {
                'gaming': {
                    name: 'æ¸¸æˆæ¨¡å¼',
                    scanlineStrength: 0.7,
                    phosphorGlow: 0.3,
                    rgbShift: 0.3,
                    contrast: 1.15,
                    noiseAmount: 0.01
                },
                'retro': {
                    name: 'å¤å¤æ¨¡å¼',
                    scanlineStrength: 0.9,
                    rgbShift: 0.6,
                    noiseAmount: 0.03,
                    flickerAmount: 0.01,
                    gamma: 2.4
                },
                'cinema': {
                    name: 'å½±é™¢æ¨¡å¼',
                    scanlineStrength: 0.4,
                    phosphorGlow: 0.2,
                    curvature: 0.15,
                    vignette: 0.3
                }
            };

            this.init();
        }

        init() {
            console.log(`%c
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘        HTML2Canvas CRT Filter System v${this.version}         â•‘
â•‘                   STATIC MODE (FIXED)                         â•‘
â•‘                                                               â•‘
â•‘  âœ… WebGL + Canvas 2D fallback                               â•‘
â•‘  âœ… Full interaction support                                 â•‘
â•‘  âœ… No recursion possible                                    â•‘
â•‘  âœ… Optimal performance                                      â•‘
â•‘                                                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`,
                'color: #00ff41; background: #000; font-family: monospace; font-weight: bold');

            this.detectRenderer();
        }

        detectRenderer() {
            const testCanvas = document.createElement('canvas');
            const gl = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');

            if (gl) {
                this.renderMode = 'webgl';
                document.getElementById('rendererInfo').textContent = 'WebGL âœ…';
                console.log('âœ… WebGL available');
            } else {
                this.renderMode = 'canvas2d';
                document.getElementById('rendererInfo').textContent = 'Canvas 2D (Fallback) âœ…';
                console.log('âš ï¸ WebGL not available, using Canvas 2D fallback');
            }
        }

        async apply() {
            if (this.active) {
                console.warn('âš ï¸ CRT filter already applied');
                return;
            }

            console.log('%cğŸ¨ Applying CRT filter...', 'color: #00ff41; font-weight: bold');

            // æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
            document.getElementById('loading-overlay').classList.add('active');
            document.getElementById('statusIndicator').classList.add('active');
            document.getElementById('statusText').textContent = 'CAPTURING...';

            try {
                // ç­‰å¾…ä¸€å¸§
                await new Promise(resolve => requestAnimationFrame(resolve));

                // ğŸ”§ å…³é”®ä¿®å¤ï¼šæ•è·æ•´ä¸ªé¡µé¢
                const originalContent = document.getElementById('original-content');

                console.log('ğŸ“¸ Capturing page with html2canvas...');

                this.capturedCanvas = await html2canvas(originalContent, {
                    scale: window.devicePixelRatio || 1,
                    useCORS: true,
                    allowTaint: false,
                    backgroundColor: null,
                    logging: false,
                    width: originalContent.scrollWidth,
                    height: originalContent.scrollHeight,
                    windowWidth: originalContent.scrollWidth,
                    windowHeight: originalContent.scrollHeight
                });

                console.log(`âœ… Page captured: ${this.capturedCanvas.width}x${this.capturedCanvas.height}`);

                document.getElementById('statusText').textContent = 'APPLYING CRT...';

                // æ‰«æäº¤äº’å…ƒç´ 
                this.scanInteractiveElements(originalContent);

                // åº”ç”¨ CRT æ•ˆæœ
                await this.applyCRTEffect();

                // éšè—åŸå§‹å†…å®¹ï¼Œæ˜¾ç¤º CRT ç‰ˆæœ¬
                originalContent.style.display = 'none';
                document.getElementById('crt-container').classList.add('active');

                // è®¾ç½®äº¤äº’å±‚
                this.setupInteractionLayer();

                this.active = true;
                document.getElementById('statusText').textContent = 'CRT ACTIVE';

                console.log('%câœ… CRT filter applied successfully!', 'color: #00ff41; font-size: 16px; font-weight: bold');
                console.log(`ğŸ“Š Render mode: ${this.renderMode.toUpperCase()}`);

            } catch (error) {
                console.error('âŒ Failed to apply CRT filter:', error);
                document.getElementById('statusText').textContent = 'ERROR';
                alert('Failed to apply CRT filter: ' + error.message);
            } finally {
                document.getElementById('loading-overlay').classList.remove('active');
            }
        }

        scanInteractiveElements(container) {
            const interactiveElements = container.querySelectorAll(
                'button, a, input, select, textarea, [onclick], [role="button"], .card'
            );

            interactiveElements.forEach(element => {
                const rect = element.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();

                this.interactionMap.set(element, {
                    x: rect.left - containerRect.left,
                    y: rect.top - containerRect.top,
                    width: rect.width,
                    height: rect.height,
                    element: element
                });
            });

            console.log(`âœ… Scanned ${interactiveElements.length} interactive elements`);
        }

        async applyCRTEffect() {
            const canvas = document.getElementById('crt-canvas');

            // è®¾ç½® canvas å°ºå¯¸
            canvas.width = this.capturedCanvas.width;
            canvas.height = this.capturedCanvas.height;

            if (this.renderMode === 'webgl') {
                await this.applyWebGLEffect(canvas);
            } else {
                await this.applyCanvas2DEffect(canvas);
            }
        }

        async applyWebGLEffect(canvas) {
            try {
                this.gl = canvas.getContext('webgl', {
                    alpha: false,
                    antialias: false,
                    preserveDrawingBuffer: true,
                    powerPreference: 'high-performance'
                });

                if (!this.gl) {
                    throw new Error('WebGL context creation failed');
                }

                await this.compileShaders();
                this.setupVertexData();
                this.setupTexture();
                this.renderWebGL();

                console.log('âœ… WebGL CRT effect applied');
            } catch (error) {
                console.warn('âš ï¸ WebGL failed, falling back to Canvas 2D:', error);
                this.renderMode = 'canvas2d';
                await this.applyCanvas2DEffect(canvas);
            }
        }

        async applyCanvas2DEffect(canvas) {
            this.ctx = canvas.getContext('2d');

            // å…ˆç»˜åˆ¶åŸå§‹å›¾åƒ
            this.ctx.drawImage(this.capturedCanvas, 0, 0);

            // è·å–å›¾åƒæ•°æ®
            const imageData = this.ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // åº”ç”¨æ‰«æçº¿æ•ˆæœ
            const scanlineSpacing = Math.floor(canvas.height / this.config.scanlineCount);
            for (let y = 0; y < canvas.height; y += scanlineSpacing) {
                for (let x = 0; x < canvas.width; x++) {
                    const index = (y * canvas.width + x) * 4;
                    const darkness = 1 - this.config.scanlineStrength * 0.5;
                    data[index] *= darkness;     // R
                    data[index + 1] *= darkness; // G
                    data[index + 2] *= darkness; // B
                }
            }

            // åº”ç”¨å¯¹æ¯”åº¦å’Œäº®åº¦
            for (let i = 0; i < data.length; i += 4) {
                // å¯¹æ¯”åº¦
                data[i] = ((data[i] / 255 - 0.5) * this.config.contrast + 0.5) * 255;
                data[i + 1] = ((data[i + 1] / 255 - 0.5) * this.config.contrast + 0.5) * 255;
                data[i + 2] = ((data[i + 2] / 255 - 0.5) * this.config.contrast + 0.5) * 255;

                // äº®åº¦
                data[i] *= this.config.brightness;
                data[i + 1] *= this.config.brightness;
                data[i + 2] *= this.config.brightness;

                // é™åˆ¶èŒƒå›´
                data[i] = Math.max(0, Math.min(255, data[i]));
                data[i + 1] = Math.max(0, Math.min(255, data[i + 1]));
                data[i + 2] = Math.max(0, Math.min(255, data[i + 2]));
            }

            // åº”ç”¨æ¸æ™•æ•ˆæœ
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const vignette = 1 - (dist / maxDist) * this.config.vignette;

                    const index = (y * canvas.width + x) * 4;
                    data[index] *= vignette;
                    data[index + 1] *= vignette;
                    data[index + 2] *= vignette;
                }
            }

            this.ctx.putImageData(imageData, 0, 0);

            console.log('âœ… Canvas 2D CRT effect applied');
        }

        async compileShaders() {
            const vertexShaderSource = `
                attribute vec2 a_position;
                attribute vec2 a_texCoord;
                varying vec2 v_texCoord;

                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                    v_texCoord = a_texCoord;
                }
            `;

            const fragmentShaderSource = `
                precision mediump float;

                uniform sampler2D u_texture;
                uniform vec2 u_resolution;

                uniform float u_intensity;
                uniform float u_scanlineStrength;
                uniform float u_scanlineCount;
                uniform float u_phosphorGlow;
                uniform float u_rgbShift;
                uniform float u_curvature;
                uniform float u_vignette;
                uniform float u_brightness;
                uniform float u_contrast;
                uniform float u_saturation;
                uniform float u_gamma;
                uniform float u_noiseAmount;
                uniform float u_maskStrength;

                varying vec2 v_texCoord;

                const float PI = 3.14159265359;

                float random(vec2 co) {
                    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
                }

                vec2 curveScreen(vec2 uv) {
                    vec2 offset = uv - 0.5;
                    offset *= vec2(1.0 + u_curvature * offset.y * offset.y,
                                  1.0 + u_curvature * offset.x * offset.x);
                    return offset + 0.5;
                }

                float scanlines(vec2 coord) {
                    float line = sin(coord.y * PI * u_scanlineCount);
                    line = line * line;
                    return 1.0 - u_scanlineStrength * u_intensity + u_scanlineStrength * u_intensity * line;
                }

                vec3 rgbShift(sampler2D tex, vec2 coord) {
                    float shift = u_rgbShift * u_intensity * 0.005;
                    vec3 color;
                    color.r = texture2D(tex, coord + vec2(shift, 0.0)).r;
                    color.g = texture2D(tex, coord).g;
                    color.b = texture2D(tex, coord - vec2(shift, 0.0)).b;
                    return color;
                }

                vec3 phosphorGlow(vec3 color, vec2 coord) {
                    float glow = u_phosphorGlow * u_intensity;
                    vec3 glowColor = color * glow;
                    float dist = length(coord - 0.5);
                    float radialGlow = 1.0 - smoothstep(0.0, 0.7, dist);
                    glowColor *= radialGlow;
                    return color + glowColor;
                }

                float vignette(vec2 coord) {
                    vec2 center = coord - 0.5;
                    float dist = length(center);
                    return 1.0 - u_vignette * u_intensity * smoothstep(0.3, 0.8, dist);
                }

                float noise(vec2 coord) {
                    float n = random(floor(coord * 100.0)) - 0.5;
                    return n * u_noiseAmount * u_intensity;
                }

                vec3 rgbMask(vec2 coord, vec3 color) {
                    if (u_maskStrength <= 0.0) return color;
                    float x = coord.x * u_resolution.x;
                    float mask = mod(x, 3.0);
                    vec3 maskColor = vec3(1.0);

                    if (mask < 1.0) {
                        maskColor = vec3(1.0, 1.0 - u_maskStrength, 1.0 - u_maskStrength);
                    } else if (mask < 2.0) {
                        maskColor = vec3(1.0 - u_maskStrength, 1.0, 1.0 - u_maskStrength);
                    } else {
                        maskColor = vec3(1.0 - u_maskStrength, 1.0 - u_maskStrength, 1.0);
                    }

                    return color * mix(vec3(1.0), maskColor, u_intensity * 0.5);
                }

                vec3 colorGrading(vec3 color) {
                    color = (color - 0.5) * u_contrast + 0.5;
                    color *= u_brightness;
                    vec3 gray = vec3(dot(color, vec3(0.299, 0.587, 0.114)));
                    color = mix(gray, color, u_saturation);
                    color = pow(max(color, vec3(0.0)), vec3(1.0 / u_gamma));
                    return color;
                }

                void main() {
                    vec2 coord = curveScreen(v_texCoord);

                    if (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0) {
                        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                        return;
                    }

                    vec3 color = rgbShift(u_texture, coord);
                    color = phosphorGlow(color, coord);
                    color *= scanlines(coord);
                    color *= vignette(coord);
                    color = rgbMask(coord, color);
                    color = colorGrading(color);
                    color += vec3(noise(coord));

                    gl_FragColor = vec4(clamp(color, 0.0, 1.0), 1.0);
                }
            `;

            const vertexShader = this.compileShader(this.gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = this.compileShader(this.gl.FRAGMENT_SHADER, fragmentShaderSource);

            this.program = this.gl.createProgram();
            this.gl.attachShader(this.program, vertexShader);
            this.gl.attachShader(this.program, fragmentShader);
            this.gl.linkProgram(this.program);

            if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
                throw new Error('Shader linking failed');
            }

            this.gl.useProgram(this.program);
        }

        compileShader(type, source) {
            const shader = this.gl.createShader(type);
            this.gl.shaderSource(shader, source);
            this.gl.compileShader(shader);

            if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                throw new Error('Shader compilation failed: ' + this.gl.getShaderInfoLog(shader));
            }

            return shader;
        }

        setupVertexData() {
            const vertices = new Float32Array([
                -1, -1,  0, 1,
                1, -1,  1, 1,
                -1,  1,  0, 0,
                1,  1,  1, 0
            ]);

            const buffer = this.gl.createBuffer();
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);

            const posLoc = this.gl.getAttribLocation(this.program, 'a_position');
            const texLoc = this.gl.getAttribLocation(this.program, 'a_texCoord');

            this.gl.enableVertexAttribArray(posLoc);
            this.gl.vertexAttribPointer(posLoc, 2, this.gl.FLOAT, false, 16, 0);

            this.gl.enableVertexAttribArray(texLoc);
            this.gl.vertexAttribPointer(texLoc, 2, this.gl.FLOAT, false, 16, 8);
        }

        setupTexture() {
            this.texture = this.gl.createTexture();
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.capturedCanvas);
        }

        renderWebGL() {
            const gl = this.gl;
            const canvas = document.getElementById('crt-canvas');

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            // è®¾ç½® uniforms
            gl.uniform1i(gl.getUniformLocation(this.program, 'u_texture'), 0);
            gl.uniform2f(gl.getUniformLocation(this.program, 'u_resolution'), canvas.width, canvas.height);

            gl.uniform1f(gl.getUniformLocation(this.program, 'u_intensity'), this.config.intensity);
            gl.uniform1f(gl.getUniformLocation(this.program, 'u_scanlineStrength'), this.config.scanlineStrength);
            gl.uniform1f(gl.getUniformLocation(this.program, 'u_scanlineCount'), this.config.scanlineCount);
            gl.uniform1f(gl.getUniformLocation(this.program, 'u_phosphorGlow'), this.config.phosphorGlow);
            gl.uniform1f(gl.getUniformLocation(this.program, 'u_rgbShift'), this.config.rgbShift);
            gl.uniform1f(gl.getUniformLocation(this.program, 'u_curvature'), this.config.curvature);
            gl.uniform1f(gl.getUniformLocation(this.program, 'u_vignette'), this.config.vignette);
            gl.uniform1f(gl.getUniformLocation(this.program, 'u_brightness'), this.config.brightness);
            gl.uniform1f(gl.getUniformLocation(this.program, 'u_contrast'), this.config.contrast);
            gl.uniform1f(gl.getUniformLocation(this.program, 'u_saturation'), this.config.saturation);
            gl.uniform1f(gl.getUniformLocation(this.program, 'u_gamma'), this.config.gamma);
            gl.uniform1f(gl.getUniformLocation(this.program, 'u_noiseAmount'), this.config.noiseAmount);
            gl.uniform1f(gl.getUniformLocation(this.program, 'u_maskStrength'), this.config.maskStrength);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        setupInteractionLayer() {
            const layer = document.getElementById('interaction-layer');
            const canvas = document.getElementById('crt-canvas');
            const wrapper = document.getElementById('crt-wrapper');

            // è®¾ç½®åŒ…è£…å™¨é«˜åº¦
            wrapper.style.height = canvas.offsetHeight + 'px';

            // ä¸ºäº¤äº’å±‚æ·»åŠ ç‚¹å‡»äº‹ä»¶
            layer.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = this.capturedCanvas.width / rect.width;
                const scaleY = this.capturedCanvas.height / rect.height;

                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;

                console.log(`ğŸ–±ï¸ Click at: ${x.toFixed(0)}, ${y.toFixed(0)}`);

                // æŸ¥æ‰¾è¢«ç‚¹å‡»çš„å…ƒç´ 
                let clicked = false;
                this.interactionMap.forEach((data, element) => {
                    if (x >= data.x && x <= data.x + data.width &&
                        y >= data.y && y <= data.y + data.height) {
                        console.log('âœ… Element clicked:', element);
                        element.click();
                        clicked = true;
                    }
                });

                if (!clicked) {
                    console.log('âš ï¸ No interactive element at this position');
                }
            });

            console.log('âœ… Interaction layer setup complete');
        }

        restore() {
            if (!this.active) {
                console.warn('âš ï¸ CRT filter not active');
                return;
            }

            document.getElementById('original-content').style.display = 'block';
            document.getElementById('crt-container').classList.remove('active');
            document.getElementById('statusIndicator').classList.remove('active');
            document.getElementById('statusText').textContent = 'READY';

            this.active = false;

            console.log('%câœ… Original page restored', 'color: #ffaa00; font-weight: bold');
        }

        preset(name) {
            const presetConfig = this.presets[name];
            if (!presetConfig) {
                console.error(`âŒ Unknown preset: ${name}`);
                return;
            }

            Object.assign(this.config, presetConfig);
            console.log(`âœ… Applied preset: ${presetConfig.name}`);

            if (this.active) {
                // é‡æ–°åº”ç”¨æ•ˆæœ
                this.applyCRTEffect();
            }
        }

        adjust(param, value) {
            if (this.config.hasOwnProperty(param)) {
                this.config[param] = value;
                console.log(`âœ… ${param} = ${value}`);

                if (this.active) {
                    this.applyCRTEffect();
                }
            } else {
                console.error(`âŒ Unknown parameter: ${param}`);
            }
        }

        help() {
            console.log(`%c
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘          HTML2Canvas CRT System - STATIC MODE (FIXED)          â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                â•‘
â•‘  ğŸš€ Usage:                                                    â•‘
â•‘    CRT.apply()          - Apply CRT filter (one-time)        â•‘
â•‘    CRT.restore()        - Restore original page              â•‘
â•‘    CRT.preset(name)     - Apply visual preset                â•‘
â•‘    CRT.adjust(p, v)     - Adjust parameter                   â•‘
â•‘                                                                â•‘
â•‘  âœ¨ Features:                                                 â•‘
â•‘    âœ… WebGL + Canvas 2D fallback                              â•‘
â•‘    âœ… Full interaction support                                â•‘
â•‘    âœ… No recursion possible                                   â•‘
â•‘                                                                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`,
                'color: #00ff41; font-family: monospace');
        }
    }

    // åˆ›å»ºå…¨å±€å®ä¾‹
    window.CRT = new StaticCRTSystem();

    // å¯åŠ¨æç¤º
    setTimeout(() => {
        console.log(
            '%cğŸ’¡ Static CRT System Ready! Type %cCRT.apply()%c to apply filter',
            'color: #888888',
            'color: #00ff41; background: #000; padding: 2px 6px; border-radius: 3px; font-weight: bold',
            'color: #888888'
        );
        CRT.help();
    }, 1000);
</script>
</body>
</html>