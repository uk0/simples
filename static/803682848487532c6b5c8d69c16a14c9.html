<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>使用python进程与线程</title>
    <meta name="description" content="笔记">
    <meta name="keywords" content="Python,lambda">
    <style>
        body {
            background-color: #f2f2f2; /* 动漫风格 */
            font-family: sans-serif;
            max-width: 820px;
            margin: 0 auto;
            padding: 20px;
            box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.1);
            transition: background-color 0.5s ease;
        }
        
        h1 {
            font-size: 20px;
            margin-bottom: 10px;
        }

        h2 {
            font-size: 18px;
            margin-bottom: 8px;
        }

        h3 {
            font-size: 16px;
            margin-bottom: 6px;
        }

        h4 {
            font-size: 14px;
            margin-bottom: 4px;
        }

        h5 {
            font-size: 12px;
            margin-bottom: 2px;
        }

        h6 {
            font-size: 11px;
            margin-bottom: 1px;
        }

        .container {
            text-align: center;
        }

        code {
            background-color: #f2f2f2; /* 与背景色一致 */
            color: #333;
            padding: 2px 4px;
            border-radius: 4px;
            font-family: monospace;
        }

        pre {
            background-color: #f0f0f0; /* 代码高亮背景色 */
            color: #222;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }

        pre code {
            background-color: transparent; /* 去掉代码块内代码的默认背景色 */
            padding: 0;
        }

        footer {
            text-align: center;
            padding: 10px 0;
            font-size: 12px;
            color: #888;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>使用python进程与线程</h1>
        <p>没事看看文章而已～</p>
        <h2>Python进程、线程、协程详解</h2>
        <h3>进程与线程的历史</h3>
        <p>我们都知道计算机是由硬件和软件组成的。硬件中的CPU是计算机的核心，它承担计算机的所有任务。
操作系统是运行在硬件之上的软件，是计算机的管理者，它负责资源的管理和分配、任务的调度。 程序是运行在系统上的具有某种功能的软件，比如说浏览器，音乐播放器等。
每次执行程序的时候，都会完成一定的功能，比如说浏览器帮我们打开网页，为了保证其独立性，就需要一个专门的管理和控制执行程序的数据结构——进程控制块。
进程就是一个程序在一个数据集上的一次动态执行过程。 进程一般由程序、数据集、进程控制块三部分组成。我们编写的程序用来描述进程要完成哪些功能以及如何完成；数据
集则是程序在执行过程中所需要使用的资源；进程控制块用来记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，它是系统感知进程存在的唯一
标志。</p>
        <pre><code>import threading
import time
 
def worker(num):
    """
    thread worker function
    :return:
    """
    time.sleep(1)
    print("The num is  %d" % num)
    return
 
for i in range(20):
    t = threading.Thread(target=worker,args=(i,)，name=“t.%d” % i)
    t.start()
</code></pre>
        <p>上述代码创建了20个“前台”线程，然后控制器就交给了CPU，CPU根据指定算法进行调度，分片执行指令。</p>
        <h3>线程锁<code>threading.RLock和threading.Lock</code></h3>
        <pre><code>import threading
import time
 
globals_num = 0
 
lock = threading.RLock()
 
def Func():
    lock.acquire()  # 获得锁
    global globals_num
    globals_num += 1
    time.sleep(1)
    print(globals_num)
    lock.release()  # 释放锁
 
for i in range(10):
    t = threading.Thread(target=Func)
    t.start()
</code></pre>
        <p>由于线程之间是进行随机调度，并且每个线程可能只执行n条执行之后，CPU接着执行其他线程。为了保证数据的准确性，引入了锁的概念。所以，可能出现如下问题：</p>
        <h3><code>threading.RLock和threading.Lock</code> 的区别</h3>
        <pre><code>import threading
lock = threading.Lock()    #Lock对象
lock.acquire()
lock.acquire()  #产生了死琐。
lock.release()
lock.release()　
import threading
rLock = threading.RLock()  #RLock对象
rLock.acquire()
rLock.acquire()    #在同一线程内，程序不会堵塞。
rLock.release()
rLock.release()
</code></pre>
        <h3><code>threading.Event</code></h3>
        <pre><code>import threading
 
def do(event):
    print('start')
    event.wait()
    print('execute')
 
event_obj = threading.Event()
for i in range(10):
    t = threading.Thread(target=do, args=(event_obj,))
    t.start()
 
event_obj.clear()
inp = input('input:')
if inp == 'true':
    event_obj.set()
</code></pre>
        <p>当线程执行的时候，如果flag为False，则线程会阻塞，当flag为True的时候，线程不会阻塞。它提供了本地和远程的并发性。</p>
        <h3><code>threading.Condition</code></h3>
        <pre><code>import threading
import time
def consumer(cond):
    with cond:
        print("consumer before wait")
        cond.wait()
        print("consumer after wait")
 
def producer(cond):
    with cond:
        print("producer before notifyAll")
        cond.notifyAll()
        print("producer after notifyAll")
 
condition = threading.Condition()
c1 = threading.Thread(name="c1", target=consumer, args=(condition,))
c2 = threading.Thread(name="c2", target=consumer, args=(condition,))
 
p = threading.Thread(name="p", target=producer, args=(condition,))
 
c1.start()
time.sleep(2)
c2.start()
time.sleep(2)
p.start()
</code></pre>
        <p>一个<code>condition</code>变量总是与某些类型的锁相联系，这个可以使用默认的情况或创建一个，当几个condition变量必须共享和同一个锁的时候，是很有用的。锁是
conditon对象的一部分：没有必要分别跟踪。</p>
        <h3><code>queue</code>模块</h3>
        <pre><code>import queue
 
q = queue.Queue(maxsize=0)  # 构造一个先进显出队列，maxsize指定队列长度，为0 时，表示队列长度无限制。
 
q.join()    # 等到队列为kong的时候，在执行别的操作
q.qsize()   # 返回队列的大小 （不可靠）
q.empty()   # 当队列为空的时候，返回True 否则返回False （不可靠）
q.full()    # 当队列满的时候，返回True，否则返回False （不可靠）
q.put(item, block=True, timeout=None) #  将item放入Queue尾部，item必须存在，可以参数block默认为True,表示当队列满时，会等待队列给出可用位置，
                                                             为False时为非阻塞，此时如果队列已满，会引发queue.Full 异常。 可选参数timeout，表示 会阻塞设置的时间，过后，
                                                              如果队列无法给出放入item的位置，则引发 queue.Full 异常
q.get(block=True, timeout=None) #   移除并返回队列头部的一个值，可选参数block默认为True，表示获取值的时候，如果队列为空，则阻塞，为False时，不阻塞，
                                                                若此时队列为空，则引发 queue.Empty异常。 可选参数timeout，表示会阻塞设置的时候，过后，如果队列为空，则引发Empty异常。
q.put_nowait(item) #   等效于 put(item,block=False)
q.get_nowait() #    等效于 get(item,block=False)
</code></pre>
        <p>代码如下：</p>
        <pre><code>#!/usr/bin/env python
import Queue
import threading
message = Queue.Queue(10)
 
 
def producer(i):
    while True:
        message.put(i)
 
 
def consumer(i):
    while True:
        msg = message.get()
 
 
for i in range(12):
    t = threading.Thread(target=producer, args=(i,))
    t.start()
 
for i in range(10):
    t = threading.Thread(target=consumer, args=(i,))
    t.start()
</code></pre>
        <p>那就自己做个线程池吧：</p>
        <pre><code># 简单往队列中传输线程数
import threading
import time
import queue
class Threadingpool():
    def __init__(self,max_num = 10):
        self.queue = queue.Queue(max_num)
        for i in range(max_num):
            self.queue.put(threading.Thread)
    def getthreading(self):
        return self.queue.get()
    def addthreading(self):
        self.queue.put(threading.Thread)
def func(p,i):
    time.sleep(1)
    print(i)
    p.addthreading()
if __name__ == "__main__":
    p = Threadingpool()
    for i in range(20):
        thread = p.getthreading()
        t = thread(target = func, args = (p,i))
        t.start()
</code></pre>
        <pre><code>#往队列中无限添加任务
import queue
import threading
import contextlib
import time
StopEvent = object()
class ThreadPool(object):
    def __init__(self, max_num):
        self.q = queue.Queue()
        self.max_num = max_num
        self.terminal = False
        self.generate_list = []
        self.free_list = []
    def run(self, func, args, callback=None):
        """
        线程池执行一个任务
        :param func: 任务函数
        :param args: 任务函数所需参数
        :param callback: 任务执行失败或成功后执行的回调函数，回调函数有两个参数1、任务函数执行状态；2、任务函数返回值（默认为None，即：不执行回调函数）
        :return: 如果线程池已经终止，则返回True否则None
        """
        if len(self.free_list) == 0 and len(self.generate_list) < self.max_num:
            self.generate_thread()
        w = (func, args, callback,)
        self.q.put(w)
    def generate_thread(self):
        """
        创建一个线程
        """
        t = threading.Thread(target=self.call)
        t.start()
    def call(self):
        """
        循环去获取任务函数并执行任务函数
        """
        current_thread = threading.currentThread
        self.generate_list.append(current_thread)
        event = self.q.get()  # 获取线程
        while event != StopEvent:   # 判断获取的线程数不等于全局变量
            func, arguments, callback = event   # 拆分元祖，获得执行函数，参数，回调函数
            try:
                result = func(*arguments)   # 执行函数
                status = True
            except Exception as e:    # 函数执行失败
                status = False
                result = e
            if callback is not None:
                try:
                    callback(status, result)
                except Exception as e:
                    pass
            # self.free_list.append(current_thread)
            # event = self.q.get()
            # self.free_list.remove(current_thread)
            with self.work_state():
                event = self.q.get()
        else:
            self.generate_list.remove(current_thread)
    def close(self):
        """
        关闭线程，给传输全局非元祖的变量来进行关闭
        :return:
        """
        for i in range(len(self.generate_list)):
            self.q.put(StopEvent)
    def terminate(self):
        """
        突然关闭线程
        :return:
        """
        self.terminal = True
        while self.generate_list:
            self.q.put(StopEvent)
        self.q.empty()
    @contextlib.contextmanager
    def work_state(self):
        self.free_list.append(threading.currentThread)
        try:
            yield
        finally:
            self.free_list.remove(threading.currentThread)
def work(i):
    print(i)
    return i +1 # 返回给回调函数
def callback(ret):
    print(ret)
pool = ThreadPool(10)
for item in range(50):
    pool.run(func=work, args=(item,),callback=callback)
pool.terminate()
# pool.close()

</code></pre>
        <h3>python 进程</h3>
        <p>multiprocessing是python的多进程管理包，和threading.Thread类似。</p>
        <h3>1、multiprocessing模块</h3>
        <pre><code>from multiprocessing import Process
 
def func(name):
    print('hello', name)
 
 
if __name__ == "__main__":
    p = Process(target=func,args=('zhangyanlin',))
    p.start()
    p.join()  # 等待进程执行完毕

</code></pre>
        <p>在使用并发设计的时候最好尽可能的避免共享数据，尤其是在使用多进程的时候。 如果你真有需要 要共享数据， multiprocessing提供了两种方式。</p>
        <h3>进程池（Using a pool of workers）</h3>
        <p>Pool类描述了一个工作进程池，他有几种不同的方法让任务卸载工作进程。</p>
        <p>进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进进程，那么程序就会等待，直到进程池中有可用进程为止。</p>
        <p>我们可以用Pool类创建一个进程池， 展开提交的任务给进程池。 例：</p>
        <pre><code>#apply
from  multiprocessing import Pool
import time
 
def f1(i):
    time.sleep(0.5)
    print(i)
    return i + 100
 
if __name__ == "__main__":
    pool = Pool(5)
    for i in range(1,31):
        pool.apply(func=f1,args=(i,))
 
#apply_async
def f1(i):
    time.sleep(0.5)
    print(i)
    return i + 100
def f2(arg):
    print(arg)
 
if __name__ == "__main__":
    pool = Pool(5)
    for i in range(1,31):
        pool.apply_async(func=f1,args=(i,),callback=f2)
    pool.close()
    pool.join()
</code></pre>
        <p>一个进程池对象可以控制工作进程池的哪些工作可以被提交，它支持超时和回调的异步结果，有一个类似map的实现。</p>
        <h3>进程池的方法</h3>
        <pre><code>apply(func[, args[, kwds]]) ：使用arg和kwds参数调用func函数，结果返回前会一直阻塞，由于这个原因，apply_asyn
c()更适合并发执行，另外，func函数仅被pool中的一个进程运行。



apply_async(func[, args[, kwds[, callback[, error_callback]]]]) ： apply()方法的一个
变体，会返回一个结果对象。如果callback被指定，那么callback可以接收一个参数然后被调用，当结果准备好回调时会调用callback，调用失败时，
则用error_callback替换callback。 Callbacks应被立即完成，否则处理结果的线程会被阻塞。



`close() `： 阻止更多的任务提交到pool，待任务完成后，工作进程会退出。



`terminate() `： 不管任务是否完成，立即停止工作进程。在对pool对象进程垃圾回收的时候，会立即调用terminate()。



`join()` : wait工作线程的退出，在调用join()前，必须调用close() or
`terminate()`。这样是因为被终止的进程需要被父进程调用wait（join等价与wait），否则进程会成为僵尸进程。



map(func, iterable[, chunksize])¶



map_async(func, iterable[, chunksize[, callback[, error_callback]]])¶



imap(func, iterable[, chunksize])¶



imap_unordered(func, iterable[, chunksize])



starmap(func, iterable[, chunksize])¶



starmap_async(func, iterable[, chunksize[, callback[, error_back]]])

</code></pre>
        <h3>python 协程</h3>
        <p>线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作则是程序员。</p>
        <p>协程存在的意义：对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次继续）。协程，则只使用一个线程，在一个线程中规定某
个代码块执行顺序。</p>
        <p>协程的适用场景：当程序中存在大量不需要CPU的操作时（IO），适用于协程；</p>
        <p>event loop是协程执行的控制点， 如果你希望执行协程， 就需要用到它们。</p>
        <p>event loop提供了如下的特性：</p>
        <ul>
            <li>注册、执行、取消延时调用(异步函数)</li>
            <li>创建用于通信的client和server协议(工具)</li>
            <li>创建和别的程序通信的子进程和协议(工具)</li>
            <li>把函数调用送入线程池中</li>
        </ul>
        <p>协程示例：</p>
        <pre><code>import asyncio
 
async def cor1():
    print("COR1 start")
    await cor2()
    print("COR1 end")
 
async def cor2():
    print("COR2")
 
loop = asyncio.get_event_loop()
loop.run_until_complete(cor1())
loop.close()
</code></pre>
        <p>最后三行是重点。</p>
        <p><code>asyncio.get_event_loop()</code>  : asyncio启动默认的event loop</p>
        <p><code>run_until_complete()</code>  :  这个函数是阻塞执行的，知道所有的异步函数执行完成，</p>
        <p><code>close()</code>  :  关闭event loop。</p>
        <h3>1、greenlet</h3>
        <pre><code>import greenlet
def fun1():
    print("12")
    gr2.switch()
    print("56")
    gr2.switch()
 
def fun2():
    print("34")
    gr1.switch()
    print("78")
 
 
gr1 = greenlet.greenlet(fun1)
gr2 = greenlet.greenlet(fun2)
gr1.switch()
</code></pre>
        <h3>2、gevent</h3>
        <p>gevent属于第三方模块需要下载安装包</p>
        <pre><code>pip3 install --upgrade pip3
pip3 install gevent
</code></pre>
        <pre><code>import gevent
 
def fun1():
    print("www.baidu.com")   # 第一步
    gevent.sleep(0)
    print("end the baidu.com")  # 第三步
 
def fun2():
    print("www.zhihu.com")   # 第二步
    gevent.sleep(0)
    print("end th zhihu.com")  # 第四步
 
gevent.joinall([
    gevent.spawn(fun1),
    gevent.spawn(fun2),
])
</code></pre>
        <p>遇到IO操作自动切换：</p>
        <pre><code>import gevent
import requests
def func(url):
    print("get: %s"%url)
    gevent.sleep(0)
    date =requests.get(url)
    ret = date.text
    print(url,len(ret))
gevent.joinall([
    gevent.spawn(func, 'https://www.pythontab.com/'),
    gevent.spawn(func, 'https://www.yahoo.com/'),
    gevent.spawn(func, 'https://github.com/'),
])
</code></pre>
    </div>
    <footer>
        Power By Gemini TextGenerate 2024-09-16 21:58:10
    </footer>
    <script>
        // 随机数种子
        Math.seedrandom(4538978253);

        // 获取当前时间，判断是白天还是夜晚
        const now = new Date();
        const hour = now.getHours();
        const isNight = hour >= 18 || hour < 6;

        // 设置背景颜色
        if (isNight) {
            document.body.style.backgroundColor = '#222';
        } else {
            document.body.style.backgroundColor = '#f2f2f2';
        }

        // 代码高亮
        const codeBlocks = document.querySelectorAll('pre code');
        codeBlocks.forEach(codeBlock => {
            // 使用DlHighlight.js实现代码高亮
            // 这里需要您自己引入DlHighlight.js库并进行相应的配置
            // 假设DlHighlight.js库已经引入并配置
            DlHighlight.highlightBlock(codeBlock);
        });
    </script>
</body>
</html>