<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>读取数据发送到MQ</title>
    <meta name="description" content="监控文件夹变动产生新文件读取该文件内容每一行都发送到RocketMQ" />
    <meta name="keywords" content="RocketMQ, Golang" />
    <style>
        body {
            background-color: #f0f0f0; /* 使用像素风格背景 */
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            max-width: 820px;
            margin: 0 auto;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }

        h1, h2, h3, h4, h5, h6 {
            text-align: center;
            margin-bottom: 10px;
        }

        h1 {
            font-size: 20px;
        }

        h2 {
            font-size: 18px;
        }

        h3 {
            font-size: 16px;
        }

        h4 {
            font-size: 14px;
        }

        h5 {
            font-size: 12px;
        }

        h6 {
            font-size: 11px;
        }

        pre {
            background-color: #f5f5f5;
            padding: 10px;
            overflow-x: auto;
        }

        code {
            font-family: monospace;
            background-color: #e8e8e8;
            padding: 2px;
        }

        .highlight {
            background-color: #f0f0f0;
        }

        footer {
            text-align: center;
            padding: 10px 0;
            font-size: 12px;
            color: #666;
            margin-top: 20px;
            border-top: 1px solid #ccc;
        }

        .highlight-code {
            background-color: #222;
            color: #ddd;
        }

        .highlight-code pre {
            background-color: #222;
            color: #ddd;
            border: none;
        }

        .highlight-code code {
            background-color: #222;
            color: #ddd;
            padding: 2px;
            font-family: monospace;
            white-space: pre-wrap; /* 保留空格和换行 */
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();

        document.addEventListener('DOMContentLoaded', function() {
            let codeBlocks = document.querySelectorAll('pre code');
            codeBlocks.forEach(block => {
                block.parentNode.classList.add('highlight-code');
            });
        });

        // 获取当前时间并根据时间设置背景色
        const now = new Date();
        const hour = now.getHours();
        if (hour >= 6 && hour < 18) { // 白天
            document.body.style.backgroundColor = '#f0f0f0';
        } else { // 夜晚
            document.body.style.backgroundColor = '#111';
        }
    </script>
</head>
<body>
    <h1>读取数据发送到MQ</h1>
    <p style="text-align: center;">监控文件夹变动产生新文件读取该文件内容每一行都发送到RocketMQ</p>

    <h2>缘由</h2>
    <p>数据通过FTP上传到服务器要求将数据发送到RocketMQ原版本用Java写的（老版本）TPS上不去资源消耗大等问题。</p>
    <p>解决方案：采用Golang 重新实现，用到了Golang的 Go关键字 WaitGroup MMAP等。</p>
    <p>目前TPS 在虚拟机上跑 TPS稳定 5600 - 4700 </p>
    <p>链接如下：<a href="https://github.com/uk0/file_to_rocketmq_middleware">https://github.com/uk0/file_to_rocketmq_middleware</a></p>

    <h2>核心代码介绍</h2>
    <pre><code class="language-go">
package main

import (
	"fmt"
	"github.com/astaxie/beego/logs"
	"github.com/zjykzk/rocketmq-client-go/log"
	"github.com/zjykzk/rocketmq-client-go/message"
	"github.com/zjykzk/rocketmq-client-go/producer"
	"math/rand"
	"os"
	"runtime"
	"strings"
	"sync/atomic"
	"time"
	"unsafe"
)

type Client struct {
	P            *producer.Producer
	Group        string
	NamesrvAddrs string
	DataChan     chan Message
}

func newLogger(filename string) (log.Logger, error) {
	file, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
	if err != nil {
		println("create file error", err.Error())
		return nil, err
	}

	logger := log.New(file, "", log.Ldefault)
	logger.Level = log.Ldebug

	return logger, nil
}

func (cli *Client) SendMsg(stati *statiBenchmarkProducerSnapshot) {
	now := time.Now()
	var count = 1;
	for messageBody := range cli.DataChan {
		m := &message.Message{Topic: messageBody.topic, Body: []byte(messageBody.line)}

		r, err := cli.P.SendSync(m)
		if err != nil {
			logs.Debug("Send with sync error:%s\n", err)
			continue
		}

		// 取模
		//var BatchLines = []message.Data{};
		//BatchLines = append(BatchLines, message.Data{Body: []byte(messageBody.line)})
		//if count%defaultSendLimitbatch == 0 {
		//
		//	r, err3 := client.SendBatchSync(&message.Batch{Topic: messageBody.topic, Datas: BatchLines})
		//	if err3 != nil {
		//		logs.Debug("SendWithBatchSync error:%s\n", err3)
		//		continue
		//	}
		//	logs.Debug(fmt.Sprintf("BatchSendMessageResult: %s FileName = %s  Process = %f%%  ProcessCount = %d , TotalCount = %d", r.OffsetID, messageBody.FileName, float32(messageBody.ProcessCount)/float32(messageBody.TotalCount)*100, messageBody.ProcessCount, messageBody.TotalCount))
		//}

		//selector
		//r, err2 := client.SendSyncWithSelector(m, messageQueueSelector{}, count)
		//if err2 != nil {
		//	logs.Debug("SendWithSelector error:%s\n", err2)
		//	continue
		//}

		if r.Status == producer.OK {
			atomic.AddInt64(&stati.receiveResponseSuccessCount, 1)
			atomic.AddInt64(&stati.sendRequestSuccessCount, 1)
			currentRT := int64(time.Since(now) / time.Millisecond)
			atomic.AddInt64(&stati.sendMessageSuccessTimeTotal, currentRT)
			prevRT := atomic.LoadInt64(&stati.sendMessageMaxRT)
			for currentRT > prevRT {
				if atomic.CompareAndSwapInt64(&stati.sendMessageMaxRT, prevRT, currentRT) {
					break
				}
				prevRT = atomic.LoadInt64(&stati.sendMessageMaxRT)
			}
			if count%1000 == 0 {
				logs.Debug(fmt.Sprintf("SendMessageResultQueueOffset : %d FileName = %s  Process = %f%%  ProcessCount = %d , TotalCount = %d", r.QueueOffset, messageBody.FileName, float32(messageBody.ProcessCount)/float32(messageBody.TotalCount)*100, messageBody.ProcessCount, messageBody.TotalCount))
			}
		}
		count++;
	}
	logs.Debug("DONE")
}

func NewMQSender(groupId string,nameSvr string) (cli *Client, err error) {
	cli = &Client{
		Group:groupId,
		NamesrvAddrs:nameSvr,
		DataChan:data,
	}
	stati := statiBenchmarkProducerSnapshot{}
	snapshots := produceSnapshots{cur: &stati}


	logger, err := newLogger("producer.log")
	if err != nil {
		logs.Debug("new logger of producer.loge error:%s\n", err)
		return
	}

	client := producer.New(groupId, strings.Split(nameSvr, ";"), logger)

	err = client.Start()
	if err != nil {
		logs.Debug("start producer error: ", err)
		return
	}
	//defer client.Shutdown()

	cli.P = client
	// 根据CPU来协商启动协程数
	for i := 0; i < runtime.GOMAXPROCS(runtime.NumCPU()); i++ {
		go func() {
			waitgroup.Add(1)
			cli.SendMsg(&stati)
			waitgroup.Done()
		}()
	}
	// snapshot
	go func() {
		waitgroup.Add(1)
		defer waitgroup.Done()
		ticker := time.NewTicker(time.Second)
		for {
			select {
			case <-ticker.C:
				snapshots.TakeSnapshot()
			}
		}
	}()
	// print statistic
	go func() {
		waitgroup.Add(1)
		defer waitgroup.Done()
		ticker := time.NewTicker(time.Second * 10)
		for {
			select {
			case <-ticker.C:
				snapshots.TrintStati()
			}
		}
	}()
	return
}

type messageQueueSelector struct{}

func (s messageQueueSelector) Select(mqs []*message.Queue, m *message.Message, arg interface{}) *message.Queue {
	orderID := arg.(int)
	return mqs[orderID%len(mqs)]
}

const (
	letterBytes   = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	letterIdxMask = 1<<6 - 1 // All 1-bits, as many as 6
)

// 随机 
var src = rand.NewSource(time.Now().UnixNano())

func RandStringBytesMaskImprSrc(n int) string {
	b := make([]byte, n)
	// A src.Int63() generates 63 random bits, enough for 10 characters!
	for i, cache, remain := n-1, src.Int63(), 10; i >= 0; {
		if remain == 0 {
			cache, remain = src.Int63(), 10
		}
		b[i] = letterBytes[int(cache&letterIdxMask)%len(letterBytes)]
		i--
		cache >>= 6
		remain--
	}
	return *(*string)(unsafe.Pointer(&b))
}


</code></pre>
    <p>* 调用方式 `	_, _ = NewMQSender(TConfig.SendGroup, TConfig.RocketMQNameserver)
`</p>
    <p>转载请注明出处，本文采用 <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">CC4.0</a> 协议授权</p>

    <footer>
        Power By Gemini TextGenerate 2024-09-16 21:21:04
    </footer>
</body>
</html>